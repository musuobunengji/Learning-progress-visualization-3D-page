1 Spring in the real world 3
1.1 Why should we use frameworks? 4
1.2 The Spring ecosystem 7
Discovering Spring Core: The foundation of Spring 8  
Using 
Spring Data Access feature to implement the app’s persistence 10
The Spring MVC capabilities for developing web apps 10  
The 
Spring testing feature 10  
Projects from the Spring ecosystem 10
1.3 Spring in real-world scenarios 12
Using Spring in the development of a backend app 12  
Using 
Spring in a test automation app 14  
Using Spring for the 
development of a desktop app 16  
Using Spring in mobile 
apps 16
1.4 When not to use frameworks 17
You need to have a small footprint 17  
Security needs dictate 
custom code 18  
Abundant existing customizations make a 
framework impractical 18  
You won’t benefit from switching 
to a framework 18
1.5 What will you learn in this book 19
2 The Spring context: Defining beans 22
2.1 Creating a Maven project 23
2.2 Adding new beans to the Spring context 29
Using the @Bean annotation to add beans into the Spring 
context 33  
Using stereotype annotations to add beans to the 
Spring context 41  
Programmatically adding beans to the Spring 
context 45
3 The Spring context: Wiring beans 50
3.1 Implementing relationships among beans defined in the 
configuration file 51
Wiring the beans using a direct method call between the @Bean 
methods 55  
Wiring the beans using the @Bean annotated 
method’s parameters 58
3.2 Using the @Autowired annotation to inject beans 61
Using @Autowired to inject the values through the class fields 61
Using @Autowired to inject the values through the constructor 64
Using dependency injection through the setter 65
3.3 Dealing with circular dependencies 66
3.4 Choosing from multiple beans in the Spring context 68
4 The Spring context: Using abstractions 75
4.1 Using interfaces to define contracts 76
Using interfaces for decoupling implementations 76  
The 
requirement of the scenario 79  
Implementing the requirement 
without using a framework 80
4.2 Using dependency injection with abstractions 85
Deciding which objects should be part of the Spring context 85
Choosing what to auto-wire from multiple implementations 
of an abstraction 91
4.3 Focusing on object responsibilities with stereotype 
annotations 96
5 The Spring context: Bean scopes and life cycle 99
5.1 Using the singleton bean scope 100
How singleton beans work 100  
Singleton beans in real-world 
scenarios 107  
Using eager and lazy instantiation 108
5.2 Using the prototype bean scope 111
How prototype beans work 111  
Prototype beans in real-world 
scenarios 115
6 Using aspects with Spring AOP 121
6.1 How aspects work in Spring 123
6.2 Implementing aspects with Spring AOP 126
Implementing a simple aspect 127  
Altering the intercepted 
method’s parameters and the returned value 135  
Intercepting 
annotated methods 140  
Other advice annotations you 
can use 143
6.3 The aspect execution chain 144
7 Understanding Spring Boot and Spring MVC 153
7.1 What is a web app? 154
A general overview of a web app 155  
Different fashions of 
implementing a web app with Spring 156  
Using a servlet 
container in web app development 159
7.2 The magic of Spring Boot 162
Using a project initialization service to create a Spring Boot 
project 162  
Using dependency starters to simplify the dependency 
management 168  
Using autoconfiguration by convention based 
on dependencies 169
7.3 Implementing a web app with Spring MVC 170
8 Implementing web apps with Spring Boot and Spring MVC 176
8.1 Implementing web apps with a dynamic view 177
Getting data on the HTTP request 182  
Using request parameters 
to send data from client to server 183  
Using path variables to 
send data from client to server 187
8.2 Using the GET and POST HTTP methods 189
9 Using the Spring web scopes 199
9.1 Using the request scope in a Spring web app 201
9.2 Using the session scope in a Spring web app 209
9.3 Using the application scope in a Spring web app 218
10 Implementing REST services 224
10.1 Using REST services to exchange data between apps 226
10.2 Implementing a REST endpoint 227
10.3 Managing the HTTP response 231
Sending objects as a response body 232  
Setting the response status 
and headers 234  
Managing exceptions at the endpoint 
level 237
10.4 Using a request body to get data from the client 242
11 Consuming REST endpoints 245
11.1 Calling REST endpoints using Spring Cloud OpenFeign 249
11.2 Calling REST endpoints using RestTemplate 253
11.3 Calling REST endpoints using WebClient 256
12 Using data sources in Spring apps 264
12.1 What a data source is 265
12.2 Using JdbcTemplate to work with persisted data 269
12.3 Customizing the configuration of the data source 278
Defining the data source in the application properties file 279
Using a custom DataSource bean 280
13 Using transactions in Spring apps 284
13.1 Transactions 287
13.2 How transactions work in Spring 289
13.3 Using transactions in Spring apps 291
14 Implementing data persistence with Spring Data 302
14.1 What Spring Data is 303
14.2 How Spring Data works 306
14.3 Using Spring Data JDBC 311
15 Testing your Spring app 323
15.1 Writing correctly implemented tests 325
15.2 Implementing tests in Spring apps 327
Implementing unit tests 328  
Implementing integration 
tests 341