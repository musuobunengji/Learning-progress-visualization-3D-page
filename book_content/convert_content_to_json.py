import json

ROLE_CHAPTER = "chapter"
ROLE_SECTION = "section"
ROLE_BULLET = "bullet"


CHAPTER_INT = "int"
CHAPTER_CHAPTER = "Chapter"
SECTION_HAS_PAGE = "has_page"
SECTION_NO_PAGE = "no_page"
BULLET_MIX = "mix"
BULLET_SINGLE = "single"

CHAPTER_RULE = {
    "is_numbered_chapter": lambda tokens: tokens[0].isdigit(),
    "is_keyword_chapter": lambda tokens: tokens[0] == "Chapter",
}

SECTION_RULE = {
    "has_page": lambda tokens: tokens[-1].isdigit(),
    "no_page": lambda tokens: not tokens[-1].isdigit(),
}

BULET_RULE = {
    "no_bullet_title": lambda tokens: not tokens[0].isdigit(),  # Using ....
    "is_single": lambda tokens: tokens[0].count(".") == 2,  # 12.2.3
}

RULE = {
    "is_chapter": lambda tokens: tokens[0].isdigit() or tokens[0] == "Chapter",
    "is_section": lambda tokens: tokens[0].count(".") == 1,
}


def detect_chapter_type(tokens, rule=CHAPTER_RULE):
    if rule["is_numbered_chapter"](tokens):
        return CHAPTER_INT
    if rule["is_keyword_chapter"](tokens):
        return CHAPTER_CHAPTER


def detect_section_type(tokens, rule=SECTION_RULE):
    if rule["has_page"](tokens):
        return SECTION_HAS_PAGE
    if rule["no_page"](tokens):
        return SECTION_NO_PAGE


def detect_bullet_type(tokens, rule=BULET_RULE):
    if rule["no_bullet_title"](tokens):
        return BULLET_MIX
    if rule["is_single"](tokens):
        return BULLET_SINGLE


def detect_role(tokens, rule=RULE):
    if rule["is_chapter"](tokens):
        return ROLE_CHAPTER
    if rule["is_section"](tokens):
        return ROLE_SECTION
    return ROLE_BULLET


def create_chapter(tokens, book_name, chapters):
    chapter_type = detect_chapter_type(tokens)
    if chapter_type == CHAPTER_INT:
        # ch_order = int(tokens[0])
        chapter = {
            "id": f"{book_name}::ch{tokens[0]}",
            "order": int(tokens[0]),
            "title": " ".join(tokens[1:-1]),
            "sections": [],
            "signals": {"bullets": [], "raw_text": ""},
        }
        chapters.append(chapter)
        return chapter
    elif chapter_type == CHAPTER_CHAPTER:
        # ch_order = int(tokens[1])
        chapter = {
            "id": f"{book_name}::ch{tokens[1]}",
            "order": int(tokens[1]),
            "title": " ".join(tokens[2:]),
            "sections": [],
            "signals": {"bullets": [], "raw_text": ""},
        }
        chapters.append(chapter)
        return chapter


def create_section(chapter, tokens):
    section_type = detect_section_type(tokens)
    if section_type == SECTION_HAS_PAGE:
        section_title = " ".join(tokens[1:-1])
        chapter["sections"].append(section_title)
        return chapter
    elif section_type == SECTION_NO_PAGE:
        section_title = " ".join(tokens[1:])
        chapter["sections"].append(section_title)
        return chapter


def create_bullet(chapter, tokens, current_bullet):
    bullet_type = detect_bullet_type(tokens)
    if bullet_type == BULLET_MIX:
        for token in tokens:
            if token.isdigit():
                if current_bullet.strip():
                    chapter["signals"]["bullets"].append(current_bullet.strip())
                current_bullet = ""
                break
            else:
                current_bullet += token + " "
    elif bullet_type == BULLET_SINGLE:
        for token in tokens:
            current_bullet += token + " "
        chapter["signals"]["bullets"].append(current_bullet)
        current_bullet = ""

    return current_bullet


def read_lines(path):
    with open(path, "r", encoding="utf-8") as f:
        return f.readlines()


def load_content_to_data(content_path, book_name, rule=RULE):
    """turn path source text to data structure"""
    chapters = []
    content_lines = read_lines(content_path)

    parser_meta = {
        "chapter_types": set(),
        "section_types": set(),
        "bullet_types": set(),
        "rule": "default_v1",
    }

    chapter = None
    current_bullet = ""  # bullet 缓冲区在「行循环外」-> bullet 是可能跨行的
    for line in content_lines:
        line = line.strip()
        if not line:
            continue

        tokens = line.split()
        role = detect_role(tokens, rule)

        if role == ROLE_CHAPTER:
            chapter_type = detect_chapter_type(tokens)
            parser_meta["chapter_types"].add(chapter_type)
            chapter = create_chapter(tokens, book_name, chapters=chapters)
        elif role == ROLE_SECTION:
            if chapter is None:
                continue
            section_type = detect_section_type(tokens)
            parser_meta["section_types"].add(section_type)
            chapter = create_section(chapter, tokens)
        elif role == ROLE_BULLET:
            if chapter is None:
                continue
            bullet_type = detect_bullet_type(tokens)
            parser_meta["bullet_types"].add(bullet_type)
            current_bullet = create_bullet(chapter, tokens, current_bullet)
    return chapters, parser_meta


def normalize_parser_meta(parser_meta):
    return {
        k: sorted(list(v)) if isinstance(v, set) else v for k, v in parser_meta.items()
    }


def load_data_to_json(book_name, chapters, parser_meta):
    data = {
        "book_id": book_name,
        "parser_meta": normalize_parser_meta(parser_meta),
        "chapters": chapters,
    }
    with open(f"{book_name}.json", "w", encoding="utf-8") as f:
        json.dump(data, fp=f, indent=4, ensure_ascii=False)


def convert_content_to_json(book_name, content_path):
    chapters, parser_meta = load_content_to_data(
        content_path=content_path, book_name=book_name
    )
    load_data_to_json(book_name=book_name, chapters=chapters, parser_meta=parser_meta)


# -------test---------
convert_content_to_json(
    book_name="spring-in-action",
    content_path=r"book_content/spring_in_action_content.txt",
)

convert_content_to_json(
    book_name="core-java", content_path=r"book_content/core_java_content.txt"
)

convert_content_to_json(
    book_name="spring-start-here",
    content_path=r"book_content/spring_start_here_content.txt",
)
